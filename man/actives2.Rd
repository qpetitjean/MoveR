% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/actives2.R
\name{actives2}
\alias{actives2}
\title{Determine active or inactive states according to density based clustering method}
\usage{
actives2(
  trackDat,
  var1 = NULL,
  var2 = NULL,
  var1T = NULL,
  var2T = NULL,
  nbins = NULL,
  na.rm = TRUE,
  graph = TRUE
)
}
\arguments{
\item{trackDat}{A list of data frame containing tracking informations for each fragment, including a vector
containing behavioral patterns (e.g., behavioral states, location in areas).}

\item{var1}{A character string indicating the name of the variable to use as the first dimension.}

\item{var2}{A character string indicating the name of the variable to use as the second dimension.}

\item{var1T}{A function used to transform var1 (e.g., log, sqrt - optional).}

\item{var2T}{A function used to transform var2 (e.g., log, sqrt - optional).}

\item{nbins}{A numeric value indicating the number of bins in both vertical and horizontal directions (default = 100).}

\item{na.rm}{A logical value indicating whether NA values should be stripped before the computation proceeds (default = TRUE).}

\item{graph}{A logical value indicating whether the various diagnostics plots should be displayed or not (default = TRUE).}
}
\value{
This function returns the results of the classification (actives vs. inactives) appended to
the original list of data frame containing tracking informations for each fragment.
}
\description{
Given a list of data frames containing tracking informations and two variable of interest the function use
density based clustering as introduced in Ester et al. (1996) and according to the DBSCAN method from Hennig (2020)
to discriminate actives and inactives states in a 2d space.
}
\examples{

# Load the sample dataset
Data <-
 MoveR::readTrex(
   system.file("sampleData/sample_1/TREXOutput", package = "MoveR"),
   mirrorY = T,
   imgHeight = 2160,
   rawDat = F
 )

# convert it to a list of fragments
trackDat <- MoveR::convert2frags(Data[1:7], by = "identity")

# infinite values that are present in the tracking output should be removed
## define the filter
filter.Inf <-
 MoveR::filterFunc(
   trackDat,
   toFilter = "x.pos",
   customFunc = function(x)
     is.infinite(x)
 )

### filter Infinite values
trackDat.Infilt <-
 MoveR::filterFrags(
   trackDat,
   filter = filter.Inf,
   splitCond = TRUE,
   minDur = 100
 )

### remove some fragment to speed up the computation
trackdat2 <- trackDat.Infilt[[2]][1:75]

# check the fragments
MoveR::drawFrags(trackdat2,
               imgRes = c(max(MoveR::convert2list(trackDat.Infilt[[2]])[["x.pos"]]),
                          max(MoveR::convert2list(trackDat.Infilt[[2]])[["y.pos"]])),
               timeCol = "frame")

# add some metric to the dataset (speed and turning angle) and time unit conversion
fragsListV1 <-
 MoveR::analyseFrags(
   trackdat2,
   customFunc = list(
     # specify a first function to compute speed over each fragment (a modulus present within the MoveR package)
     speed = function(x)
       MoveR::speed(
         x,
         TimeCol = "frame",
         scale = 1,
         unit = "pixels"
       ),
     # compute turning angle in radians over each fragment (a modulus present within the MoveR package)
     TurnAngle = function(x)
       MoveR::turnAngle(x, unit = "radians")
   )
 )

# smooth the computed metric by computing the mean value over a 10 frames' sliding window 
fragsListV1Smoothed <-
 MoveR::analyseFrags(
   fragsListV1,
   customFunc = list(
     # smooth variance of turning angles
     SlideVarAngle = function (y)
       MoveR::slidWin(y$TurnAngle,
                     Tstep = 10, function (x)
                       circular::var(
                         circular::circular(
                           x,
                           type = "angle",
                           units = "radians",
                           zero = 0
                         ),
                         na.rm = T
                       )),
     # smooth speed
     SlidemeanSpeed = function (y)
       MoveR::slidWin(y$speed,
                     Tstep = 10, function (x)
                       mean(x, na.rm = T))
   )
)

# use density based clustering to classify actives and inactives states in a 2 dimension array (here the speed and the angle variance)
# when graph = TRUE, several graphical output are displayed: 
# - the distribution of inactives states
# - the resuls of the density based clustering with the two groups displayed
# - a similar representation but as hexbinplot, with the count 
# - the final representation of the 2d clustering with the increasing size of the dot representing the increasing number of count
# - a pie chart representing the proportion of actives vs inactives states

fragsListV1Smoothed <- actives2(
 fragsListV1Smoothed,
 var1 = "SlidemeanSpeed",
 var2 = "SlideVarAngle",
 var1T = log10,
 var2T = NULL,
 nbins = 100,
 na.rm = TRUE,
 graph = TRUE
) 

}
\references{
Christian Hennig (2020). fpc: Flexible Procedures for Clustering. R package version 2.2-9. https://CRAN.R-project.org/package=fpc
Martin Ester, Hans-Peter Kriegel, Joerg Sander, Xiaowei Xu (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise. Institute for Computer Science, University of Munich. Proceedings of 2nd International Conference on Knowledge Discovery and Data Mining (KDD-96).
}
