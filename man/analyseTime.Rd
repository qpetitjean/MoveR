% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analyseTime.R
\name{analyseTime}
\alias{analyseTime}
\title{perform analysis across fragments and time}
\usage{
analyseTime(
  trackDat,
  timeCol = NULL,
  customFunc = NULL,
  Tinterval = NULL,
  Tstep = 1,
  sampling = 1,
  wtd = FALSE
)
}
\arguments{
\item{trackDat}{A list of data frame containing tracking informations for each fragment (including a timeline).}

\item{timeCol}{A character string corresponding to the name of the column containing time information.}

\item{customFunc}{A function or a list of functions used to perform the computation across time.
NB: in case customFunc is a list of unnamed function it will try to retrieve their names by returning the first character string
following the function() call as the name of the results column.}

\item{Tinterval}{A vector containing two numeric values expressed in the timeline unit and
specifying the time interval on which the computation is performed (default is null, meaning the computation will be performed on the whole timeline).}

\item{Tstep}{A numeric value expressed in the timeline unit and specifying the size of the
sliding window used to perform the computation (e.g., a value of 200, mean that for each sampling point, the computation
is performed using the 100 previous and the 100 next values).}

\item{sampling}{A numeric value expressed in the timeline unit and specifying a subsampling used to
to perform the computation, allow to make computation faster, it hence determine the resolution of the
returned results (e.g., a value of 5000 mean that values will be computed every 5000 time units).}

\item{wtd}{TRUE or FALSE, compute a weighed metric (TRUE) or not (FALSE) according to the length of the fragments (default is FALSE).}
}
\value{
this function returns a list containing as much data frame as the number of custom functions specified by
the customFunc argument. Each dataframe includes a column indicating the timeline according to timeCol and sampling arguments
as well as the result of the computation performed according to the customFunc.
}
\description{
Given a list of data frames containing tracking informations for each fragment (including the timeline)
and a custom function, this function perform the computation specified by the custom function(s) across time
and smooth it and returns a list containing as much data frame as the number of custom functions specified by
the customFunc argument. Each data frame includes a column indicating the timeline and the result of the computation across time.
}
\examples{

# generate some dummy fragments
## start to specify some parameters to generate fragments
Fragn <- 25 # the number of fragment to simulate
FragL <-
 100:1000 # the length of the fragments or a sequence to randomly sample fragment length

fragsList <- stats::setNames(lapply(lapply(seq(Fragn), function(i)
 trajr::TrajGenerate(sample(FragL, 1), random = TRUE, fps = 1)), function(j)
   data.frame(
     x.pos = j$x - min(j$x),
     y.pos = j$y - min(j$y),
     frame = j$time
   )), seq(Fragn))

# check the fragments
drawFrags(fragsList,
         imgRes = c(max(MoveR::convert2list(fragsList)[["x.pos"]]),
                    max(MoveR::convert2list(fragsList)[["y.pos"]])),
         timeCol = "frame")

# add some metric to the dataset (speed and turning angle) and time unit conversion
fragsListV1 <-
 MoveR::analyseFrags(
   fragsList,
   customFunc = list(
     # specify a first function to compute speed over each fragment (a modulus present within the MoveR package)
     speed = function(x)
       MoveR::speed(
         x,
         TimeCol = "frame",
         scale = 1,
         unit = "pixels"
       ),
     # compute turning angle in radians over each fragment (a modulus present within the MoveR package)
     TurnAngle = function(x)
       MoveR::turnAngle(x, unit = "radians"),
     # convert the time expressed in frame in second using a conversion factor of 25 frame per second
     TimeSec = function(x)
       x[["frame"]] / 25,
     # or in minutes
     TimeMin = function(x)
       x[["frame"]] / 25 / 60
   )
 )

# smooth the speed and the turning angle across fragments and time, here we perform the computation 
# every 50 time unit and on an interval of 100 values, 50 values are taken before and 50 values after the given time unit.
Smoothedtracks <- MoveR::analyseTime(
 trackDat = fragsListV1,
 timeCol = "frame",
 Tstep = 100,
 sampling = 50,
 wtd = TRUE,
 customFunc = list(
   MeanSpeed = function(x)
     mean(x[["speed"]], na.rm = T),
   MeanTurnAngle = function(x)
     mean(x[["TurnAngle"]], na.rm = T)
 )
)

# plot the results
par(mfrow = c(1, 2))
plot(Smoothedtracks[["MeanSpeed"]]$MeanSpeed ~ Smoothedtracks[["MeanSpeed"]]$frame, type = "l")
plot(Smoothedtracks[["MeanTurnAngle"]]$MeanTurnAngle ~ Smoothedtracks[["MeanTurnAngle"]]$frame, type = "l")

}
