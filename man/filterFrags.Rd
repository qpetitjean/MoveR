% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filterFrags.R
\name{filterFrags}
\alias{filterFrags}
\title{apply a custom filter on tracking fragments.}
\usage{
filterFrags(trackDat, filter, splitCond = TRUE, minDur = 1)
}
\arguments{
\item{trackDat}{A list of data frames containing tracking informations for each fragment.}

\item{filter}{A list of vector as returned by filterFunc and containing the result of a condition test.}

\item{splitCond}{The result of the condition test for which values have to be removed and fragments have to be splitted (Default: TRUE).}

\item{minDur}{The minimum duration (i.e., number of records) to consider a fragment valid after the filtering (default = 1).}
}
\value{
This function returns a list containing two sublists:
\itemize{
\item{"Summary_filtering": }{a list containing a summary of the informations about the fragments before and after filtering:
\itemize{
\item{"Fragnb_before_filter": }{the initial number of fragment.}
\item{"Fragnb_after_filter": }{the number of remaining fragment after filtering, according to the "filter" argument.}
\item{"Fragnb_after_minDur": }{the number of remaining fragment after filtering that have a number of records above "minDur" argument.}
\item{"TotFragDuration_before_filter": }{the sum of the records belonging to each fragment before the filtering.}
\item{"TotFragDuration_after_filter": }{the sum of the records belonging to each fragment after the filtering.}
\item{"TotFragDuration_after_minDur": }{the sum of the records belonging to each fragment that have a number of records above "minDur" argument after the filtering.}
\item{"\%Data_kept_after_filter": }{the percent of records remaining afer the filtering.}
\item{"\%Data_kept_after_minDur": }{the percent of records remaining afer the filtering for the fragments that have a number of records above "minDur" argument only.}
}}
\item{"Cleaned_frags": }{a list of data frames containing the filtered fragments according to the condition test specified by filterFunc and "minDur" argument.}
}
}
\description{
Given a list of data frame containing tracking information for each fragment and the result
of a specified condition' test as returned by filterFunc this function remove the values that do not meet the condition
of the test and split the fragments accordingly. Also by specifying an additional "minDur" argument,
filtered fragment that have a low number of records can be removed.
The function hence returns two sublist, the first containing a summary of the informations about the fragments before and after filtering
and, second a list containing the filtered fragments according to the condition test and "minDur" argument.
}
\examples{

# load the sample data
Data <-
 readTrex(
   system.file("sampleData/sample_1/TREXOutput", package = "MoveR"),
   mirrorY = T,
   imgHeight = 2160,
   rawDat = F
 )
# convert it to a list of fragments
trackDat <- convert2frags(Data[1:7], by = "identity")

## Exemple 1: test for the presence of infinite value in x.pos,
 # if infinite values are detected, the result is TRUE 

FiltInf <- filterFunc(trackDat, toFilter = "x.pos", customFunc = function(x) is.infinite(x))

 # Then remove infinite values and split the fragments when an infinite value is found
 # here we keep every remaining fragment, whatever its duration (the number of record within each fragment)

trackDat_NoInf <- filterFrags(trackDat, filter = FiltInf, splitCond = TRUE, minDur = 1)

 # Check the summary of the filtering
 
str(trackDat_NoInf$Summary_filtering)

 # access to the filtered fragment list
 
 trackDat_NoInf$Cleaned_frags

 # alternatively, we can only keep the fragments with a duration above 10 (the number of record within each fragment) by modifying the minDur argument

trackDat_NoInf_Dur10 <- filterFrags(trackDat, filter = FiltInf, splitCond = TRUE, minDur = 10)

 # Check the summary of the filtering
 
str(trackDat_NoInf_Dur10$Summary_filtering)

 # access to the filtered fragment list
 
 trackDat_NoInf_Dur10$Cleaned_frags

## Exemple 2: test for the length of the individuals, 
 # if individual size is ranging between 1 and 20 pixels, the result is TRUE 
 
FiltSize <- filterFunc(trackDat, toFilter = "maj.ax", customFunc = function(x) x >= 1 & x <= 20)

 # Then remove values that are not included within the [1:20] interval and split the fragments accordingly
 # here we keep every remaining fragment, whatever its duration (the number of record within each fragment)

trackDat_Size20 <- filterFrags(trackDat, filter = FiltSize, splitCond = TRUE, minDur = 1)

 # Check the summary of the filtering
 
str(trackDat_Size20$Summary_filtering)

 # access to the filtered fragment list
 
 trackDat_Size20$Cleaned_frags
 
 # alternatively, we can only keep the fragments with a duration above 10 (the number of record within each fragment) by modifying the minDur argument

trackDat_Size20_Dur10 <- filterFrags(trackDat, filter = FiltSize, splitCond = TRUE, minDur = 10)

 # Check the summary of the filtering
 
str(trackDat_Size20_Dur10$Summary_filtering)

 # access to the filtered fragment list
 
 trackDat_Size20_Dur10$Cleaned_frags


}
\seealso{
\code{\link{filterFunc}}
}
\author{
Quentin PETITJEAN
}
