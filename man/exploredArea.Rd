% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/exploredArea.R
\name{exploredArea}
\alias{exploredArea}
\title{Compute the total surface explored and display the corresponding heatmap.}
\usage{
exploredArea(
  trackDat,
  binRad = NULL,
  imgRes = c(1920, 1080),
  scale = 1,
  timeCol = "frame",
  timeWin = list(c(0, Inf)),
  saveGraph = FALSE
)
}
\arguments{
\item{trackDat}{A list of data frame containing tracking informations for each fragment (including a timeline)
or a data frame containing tracking information for one fragment.}

\item{binRad}{A numeric value corresponding to the diameter of the typical surface a particle can "explore" around its position
For instance, the reaction distance of a Trichograms (i.e., a parasitoid micro-wasp) is about 4 mm, in this case, a reasonable value is of order 16 mm^2,
the diameter of such a cell is hence about 8 mm.}

\item{imgRes}{A vector of 2 numeric values, the resolution of the video used as x and y limit of the plot
(i.e., the number of pixels in image width and height, e.g., 1920 x 1080).}

\item{scale}{A ratio corresponding to the scaling factor to be applied to the trajectory coordinates (optional).}

\item{timeCol}{A character string corresponding to the name of the column containing Time information (e.g., "frame").}

\item{timeWin}{A list of one or several vector containing 2 numeric values separated by a comma
corresponding to the time interval between which the fragments have to be drawn according to timeCol (optional).}

\item{saveGraph}{A logical value indicating whether the heatmap should be saved as a .tiff file in the hardrive - within the working directory (default = FALSE).
Alternatively, the user can specify the saving function and hence the extension and the
directory where the heatmap should be saved (see for instance grDevices::png(), grDevices::jpeg() or grDevices::tiff()).}
}
\value{
displays an heatmap (i.e., hexbin plot) of the explored areas and returns the
total surface explored in a geometrically consistent and scalable manner
}
\description{
Given a list of tracking fragments containing cartesian coordinates, and a value of
reaction distance this function displays an heatmap (i.e., hexbin plot) of the explored areas and returns the
total surface explored in a geometrically consistent and scalable manner.
}
\examples{

# generate some dummy fragments
## start to specify some parameters to generate fragments
Fragn <- 20 # the number of fragment to simulate
FragL <- 100:1000 # the length of the fragments or a sequence to randomly sample fragment length

fragsList <- stats::setNames(lapply(lapply(seq(Fragn), function(i)
 trajr::TrajGenerate(sample(FragL, 1), random = TRUE, fps = 1)), function(j)
   data.frame(
     x.pos = j$x - min(j$x),
     y.pos = j$y - min(j$y),
     frame = j$time
   )), seq(Fragn))

# check the fragments

MoveR::drawFrags(fragsList,
         imgRes = c(max(MoveR::convert2list(fragsList)[["x.pos"]]),
                    max(MoveR::convert2list(fragsList)[["y.pos"]])),
         timeCol = "frame")

# extract image resolution
imgRes <- c(max(MoveR::convert2list(fragsList)[["x.pos"]]), 
           max(MoveR::convert2list(fragsList)[["y.pos"]]))
# compute the total surface explored and displays the heatmap for all fragments
# and save the plot in the working directory using user specified parameters (saveGraph argument)
# if saveGraph is "TRUE", the plot is saved in the working directory as .tiff image
# if saveGraph is "FALSE", the plot is only displayed.
MoveR::exploredArea(fragsList,
            binRad = 8,
            imgRes = imgRes,
            scale = 1,
            timeCol = "frame",
            timeWin = list(c(0, Inf)),
            saveGraph = grDevices::tiff("exploredPlotTest.tiff",
                                        width = 600,
                                        height = 600
            ))

# compute the surface explored for each fragment and display (but do not save) the heatmap for each fragment
# here by combining exploredArea and analyseFrags, the surface explored for each fragment will be appended to the data
# of the corresponding fragment.
MoveR::analyseFrags(
 fragsList,
 customFunc = list(
   exploredArea = function(x)
     exploredArea(
       x,
       binRad = 8,
       imgRes = imgRes,
       scale = 1,
       timeCol = "frame",
       timeWin = list(c(0, Inf)),
       saveGraph = FALSE
     ))
)

}
\author{
Quentin PETITJEAN
}
