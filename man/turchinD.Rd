% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/turchinD.R
\name{turchinD}
\alias{turchinD}
\title{Compute the net square displacement (Turchin 1998).}
\usage{
turchinD(trackDat, turnAngle = NULL, distTraveled = NULL, behavStates = NULL)
}
\arguments{
\item{trackDat}{A list of data frame containing tracking informations for each fragment, including a vector
containing behavioral patterns (e.g., behavioral states, location in areas).}

\item{turnAngle}{A character string indicating the name of the variable specifying the turning angles over each trajectories.}

\item{distTraveled}{A character string indicating the name of the variable specifying the distance traveled by the particles.}

\item{behavStates}{A character string indicating the name of the variable specifying behavioral states.}
}
\value{
this function returns the net square displacement value used to infer populations spread according to Turchin (1998).
}
\description{
Given a list of data frames containing tracking informations and including the value of turning angles,
distance traveled and behavioral states (either active or inactive), this function compute the Net square displacement value
used to infer populations spread according to Turchin (1998).
}
\examples{

# simulate a correlated random walk with known parameter to verify Turchin D computation
## specify some parameters
n = 1000
stepLength = 2
angularErrorSd = 0.5
linearErrorSd = 0.2
angularErrorDist = stats::rnorm(n, sd = angularErrorSd)
linearErrorDist = stats::rnorm(n, sd = linearErrorSd)

## simulate a trajectory
sim <- trajr::TrajGenerate(
 n = n,
 random = TRUE,
 stepLength = stepLength,
 angularErrorSd = angularErrorSd,
 angularErrorDist = function(x) angularErrorDist,
 linearErrorSd = linearErrorSd,
 linearErrorDist = function(x) linearErrorDist,
 fps = 1)

## convert it to a data frame to allow MoveR computation
sim <- data.frame(
 x.pos = sim[["x"]] - min(sim[["x"]]),
 y.pos = sim[["y"]] - min(sim[["y"]] ),
 frame = sim[["time"]]
)

# take a look at the simulated data (here we use list(sim) because the function expect a list of trajectories)
MoveR::drawFrags(list(sim), imgRes = c(500,500))

# compute the needed metric on the simulated dataset (here we use list(sim) because the function expect a list of trajectories)
simComp <-
 MoveR::analyseFrags(
   list(sim),
   customFunc = list(
     ## compute turning angle in radians over each fragment (a modulus present within the MoveR package)
     TurnAngle = function(x)
       MoveR::turnAngle(x, unit = "radians"),
     ## compute distance traveled
     distTraveled = function(x)
       MoveR::distTraveled(x, step = 1)
   )
 )

# add behavioral state (consider as active all the time)
simComp[[1]]["behavStates"] <- "active"

# compute the Turchin net square displacement from the simulated data
D <- MoveR::turchinD(
 simComp,
 turnAngle = "TurnAngle",
 distTraveled = "distTraveled",
 behavStates = "behavStates"
)

# check the net square displacement value D

}
\references{
Turchin, P. (1998). Quantitative Analysis of Movement: Measuring and Modeling Population Redistribution in Animals and Plants. Sinauer.
}
\author{
Quentin PETITJEAN
}
