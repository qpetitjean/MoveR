% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/temporalBoot.r
\name{temporalBoot}
\alias{temporalBoot}
\title{perform analysis across tracklets and time.}
\usage{
temporalBoot(
  trackDat,
  timeCol = NULL,
  customFunc = NULL,
  Tinterval = NULL,
  Tstep = 1,
  sampling = 1,
  bootn = 500,
  wtd = FALSE
)
}
\arguments{
\item{trackDat}{A list of data frame containing tracking informations for each tracklet (including a timeline).}

\item{timeCol}{A character string specifying the name of the timeline column.}

\item{customFunc}{A function used to perform the computation across time.}

\item{Tinterval}{A vector containing two numeric values expressed in the timeline unit and
specifying the time interval on which the computation is performed
(default is null, meaning the computation will be performed on the whole timeline).}

\item{Tstep}{A numeric value expressed in the timeline unit and specifying the size of the
sliding window used to perform the computation.}

\item{sampling}{A numeric value expressed in the timeline unit and specifying a subsampling used to
to perform the computation, allow to make computation faster, it hence determine the resolution of the
returned results (e.g., 5000 mean that values will be computed every 5000 frames).}

\item{bootn}{A numeric value corresponding to the number of bootstrap sampling to compute studentize 95\%IC.}

\item{wtd}{TRUE or FALSE, compute a weighed metric (TRUE) or not (FALSE), (default is FALSE).}
}
\value{
this function returns a list containing two sublist, the first sublist contains a dataframe with
bootstrap results (CI 97.5\%, CI 2.5\%, mean, the resampled timeline according to timeCol argument and the number of tracklet sampled),
the second sublist contains various results depending on wtd argument.
If wtd is FALSE, the second list returns a list of the sampled time point (e.g., frame), each one
containing a dataframe with values sampled over the bootstrap.
If wtd is TRUE, the second list returns a list of the sampled time point (e.g., frame), each one
containing a dataframe with values of weighed mean and sd computed over the bootstrap sampling.
}
\description{
Given a list of data frames containing tracking informations for each tracklet (including the timeline)
and a custom function, this function perform the computation specified by the custom function across time
and smooth it before returning values.
}
\examples{
# generate some dummy tracklets
## start to specify some parameters to generate tracklets
Fragn <- 25 # the number of tracklet to simulate
FragL <-
 100:1000 # the length of the tracklets or a sequence to randomly sample tracklet length

fragsList <- stats::setNames(lapply(lapply(seq(Fragn), function(i)
 trajr::TrajGenerate(sample(FragL, 1), random = TRUE, fps = 1)), function(j)
   data.frame(
     x.pos = j$x - min(j$x),
     y.pos = j$y - min(j$y),
     frame = j$time
   )), seq(Fragn))

# check the tracklets
MoveR::drawTracklets(fragsList,
               imgRes = c(max(MoveR::convert2List(fragsList)[["x.pos"]]),
                          max(MoveR::convert2List(fragsList)[["y.pos"]])),
               timeCol = "frame")

# add some metric to the dataset (speed and turning angle) and time unit conversion
fragsListV1 <-
 MoveR::analyseTracklets(
   fragsList,
   customFunc = list(
     # specify a first function to compute speed over each tracklet (a modulus present within the MoveR package)
     speed = function(x)
       MoveR::speed(
         x,
         TimeCol = "frame",
         scale = 1),
     # compute turning angle in radians over each tracklet (a modulus present within the MoveR package)
     TurnAngle = function(x)
       MoveR::turnAngle(x, unit = "radians"),
     # convert the time expressed in frame in second using a conversion factor of 25 frame per second
     TimeSec = function(x)
       x[["frame"]] / 25,
     # or in minutes
     TimeMin = function(x)
       x[["frame"]] / 25 / 60
   )
 )

# smooth the speed and the turning angle across tracklets and time, here we perform the computation 
# every 50 time unit and on an interval of 100 values, 50 values are taken before and 50 values after the given time unit. 
# and compute studentize 95\% CI using bootstrap with 999 sampling. 
SmoothedtracksBoot <- MoveR::temporalBoot(
 trackDat = fragsListV1,
 timeCol = "frame",
 Tstep = 100,
 sampling = 50,
 wtd = TRUE,
 bootn = 999,
 customFunc = list(
   MeanSpeed = function(x)
     mean(x[["speed"]], na.rm = T),
   MeanTurnAngle = function(x)
     mean(x[["TurnAngle"]], na.rm = T)
 )
)

# plot the results
## need to remove the NA introduced during smoothing to plot the 95\% CI envelope
SmoothedtracksBootCInoNA <-
 lapply(SmoothedtracksBoot[["BootCiStudent"]], function(x)
   x[!is.na(x[["mean"]]), ])

## plot the mean and the 95\% CI envelope by looping through the list containing the smoothed results for the speed and the turning angle
par(mfrow = c(1, 2))
for (i in seq(length(SmoothedtracksBootCInoNA))) {
 plot(
   SmoothedtracksBootCInoNA[[i]]$mean ~ SmoothedtracksBootCInoNA[[i]]$frame,
   type = "l",
   ylab = names(SmoothedtracksBootCInoNA)[[i]],
   xlab = "Time (frame)",
   ylim = c(round(min(
     c(
       SmoothedtracksBootCInoNA[[i]]$`2.5\%`,
       SmoothedtracksBootCInoNA[[i]]$`97.5\%`
     ) ,
     na.rm = T
   ), digits = 5),
   round(max(
     c(
       SmoothedtracksBootCInoNA[[i]]$`2.5\%`,
       SmoothedtracksBootCInoNA[[i]]$`97.5\%`
     ),
     na.rm = T
   ), digits = 5))
 )
 polygon(
   x = c(
     SmoothedtracksBootCInoNA[[i]]$frame,
     rev(SmoothedtracksBootCInoNA[[i]]$frame)
   ),
   y = c(
     SmoothedtracksBootCInoNA[[i]]$`2.5\%`,
     rev(SmoothedtracksBootCInoNA[[i]]$`97.5\%`)
   ),
   col = rgb(1, 0, 0, 0.1),
   border = NA,
   density = NA
 )
}

}
\author{
Quentin PETITJEAN
}
