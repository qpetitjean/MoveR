setNames(c(TrackList,trackDatflipped), c(1:2)),
colId = "identity",
selTrack = c(1,2))
# draw the result
# here we can see that both trajectory are flipped, with the original trajectory
# drawed in black and the flipped one in red
MoveR::drawTracklets(
setNames(c(TrackList,trackDatflipped), c(1:2)),
selTrack = c(1,2))
trackDatflipped
str(trackDatflipped)
trackDatflipped[["identity"]]
# rename the identity of the flipped tracklet Tracklet_1_Flip
gsub(trackDatflipped[[1]][["identity"]])
gsub("Tracklet_1", "Tracklet_1_Bis", trackDatflipped[[1]][["identity"]])
trackDatflipped[[1]][["identity"]]\
trackDatflipped[[1]][["identity"]]
# rename the identity of the flipped tracklet Tracklet_1_Bis
trackDatflipped[[1]][["identity"]] <- gsub("Tracklet_1", "Tracklet_1_Bis", trackDatflipped[[1]][["identity"]])
# draw the result
# here we can see that both trajectory are flipped, with the original trajectory
# drawed in black and the flipped one in red
MoveR::drawTracklets(
setNames(c(TrackList,trackDatflipped), c(1:2)),
colId = "identity")
# draw the result
# here we can see that both trajectory are flipped, with the original trajectory
# drawed in black and the flipped one in red
MoveR::drawTracklets(c(TrackList, trackDatflipped),
colId = "identity")
gc()
# Download the first dataset from the sample data repository
Path2Data <- MoveR::DLsampleData(dataSet = 1, tracker = "TRex")
Path2Data
# Import the list containing the 9 vectors classically used for further computation
# and flip Y coordinates to start on the bottom-left
Data <- MoveR::readTrex(Path2Data[[1]],
flipY = T,
imgHeight = 2160,
rawDat = F)
str(Data)
# convert it to a list of tracklets
trackDat <- MoveR::convert2Tracklets(Data[1:7], by = "identity")
# Import the reference dataset (A matrix or dataframe or path to a file (either .txt or .csv) containing a distance matrix to any object or
# the location of one or several areas of interest (here we have created a distance map using ImageJ)
refDat <- read.delim(Path2Data[[2]],
dec = ".")
##  transform the refDat as matrix while keeping numeric values
refDat <- matrix(as.numeric(unlist(refDat)), nrow = nrow(refDat))
##  retrieve the value of the edge limit (1) and of the center limit (254) to plot them
arenaEdge <-
stats::setNames(data.frame(which(refDat == 1, arr.ind = T)),
c("y.pos", "x.pos"))
arenaCenter <-
stats::setNames(data.frame(which(refDat == 254, arr.ind = T)),
c("y.pos", "x.pos"))
#' @title Locate a particle position.
#'
#' @description Given the position of a particle along its trajectory (a tracklet) and a reference matrix indicating the location of areas of interest in the same coordinates system
#' as those specifying the particle' position, this function retrieve the value (area of interest) given by the reference matrix for the corresponding coordinates over the particle' trajectory.
#'
#'
#' @param refDat A matrix or dataframe or path to a file (either .txt or .csv) containing a distance matrix to any object or
#' the location of one or several areas of interest (e.g., create a distance map using ImageJ - with x and y coordinates as columns and rows names respectively).
#'
#' @param df A data frame containing x and y coordinates in columns named "x.pos", "y.pos" for a given tracklet.
#'
#' @param sep The field separator character, the values on each line of the file are separated by this character (optional, needed only if refDat argument is a path).
#'
#' @param dec The character used in the file for decimal points (optional, needed only if refDat is a path).
#'
#' @param Fun A custom function used to transform the data from df (e.g., round, ceiling, log).
#' NB: Indeed, while the tracking software generally return cartesian coordinates (x and y) as decimal numbers, distances map does not,
#' it could hence be necessary to round the x and y coordinates to find correspondences with refDat.
#'
#' @return This function returns a vector containing the position of a particle over its trajectory according to a distance matrix to any object or a matrix containing the location of
#' an area of interest.
#'
#' @author Quentin PETITJEAN
#'
#'
#' @examples
#'
#'# load the sample data
#'Data <-
#'  readTrex(
#'    system.file("sampleData/sample_1/TREXOutput", package = "MoveR"),
#'    flipY = T,
#'    imgHeight = 2160,
#'    rawDat = F
#'  )
#'# convert it to a list of tracklets
#'trackDat <- convert2Tracklets(Data[1:7], by = "identity")
#'
#'# load the reference dataset (A matrix or dataframe or path to a file (either .txt or .csv) containing a distance matrix to any object or
#'# the location of one or several areas of interest (here we have created a distance map using ImageJ)
#'refDat <-
#'  as.matrix(read.delim(
#'    system.file("sampleData/sample_1/ReferenceData/TREXOutput/RefDat_2602_ISA3080_Low_5.csv", package = "MoveR"),
#'    dec = "."
#'  ))
#'##  retrieve the value of the edge limit (1) and of the center limit (254) to plot them
#'arenaEdge <- data.frame(which(refDat == 1, arr.ind=T))
#'arenaCenter <- data.frame(which(refDat == 254, arr.ind=T))
#'
#'## then specify that all values above 254 are considered as the center
#'refDat[which(as.numeric(refDat) > 254)] <- "center"
#'## rather all values above 0 and below or equal to 254 are considered as within the border
#'refDat[which(as.numeric(refDat) >= 0 & as.numeric(refDat) <= 254)] <- "edge"
#'
#'# retrieve the area where the particles
#'# are located over their whole trajectory using locaPos function
#'trackDat <- analyseTracklets(trackDat,
#'                         customFunc = list(
#'                           Position = function(x)
#'                             locaPos(refDat, x)))
#'# draw the result, with tracklets part that are on the edge of the arena colored in red
#'# and those at the center in black
#'drawTracklets(
#'  trackDat,
#'  imgRes = c(3840, 2160),
#'  add2It = list(
#'    points(x = arenaEdge[, 2], y = arenaEdge[, 1], cex = 0.01),
#'    points(x = arenaCenter[, 2], y = arenaCenter[, 1], cex = 0.01)
#'  ),
#'  colId = "Position"
#')
#'
#' @export
locaPos <-
function(refDat = NULL,
df = NULL,
sep = NULL,
dec = NULL,
Fun = NULL) {
if (is.null(refDat)) {
stop(
"refDat argument is missing, the function need a reference matrix to retrieve the location of the given particle"
)
}
if (is.null(df)) {
stop(
"df argument is missing, \nthe function need a data frame containing x and y coordinates of a given particules along a trajectory to retrieve its location"
)
}
if (!is.data.frame(df)) {
stop(
"df is not a dataframe, \nconsider transforming the data, the function need a data frame containing x and y coordinates of a given particules along a trajectory to retrieve its location"
)
}
if (!is.data.frame(df)) {
stop(
"df does not contain x.pos and y.pos, \nverify that x and y coordinates of the particles are present in the df or are named x.pos and y.pos"
)
}
if (!is.data.frame(refDat) &
!is.matrix(refDat) &
!is.array(refDat) & is.character(refDat)) {
extens <- sub("^(.*\\.|[^.]+)(?=[^.]*)", "", refDat, perl = TRUE)
if (is.null(dec)) {
dec <- "."
warning(paste(
"dec argument is missing, default decimal points is",
deparse("."),
sep = " "
))
}
if (extens == "txt") {
if (is.null(sep)) {
sep <- "\t"
warning(
paste(
"sep argument is missing, for a .txt file default field separator is",
deparse("\t"),
sep = " "
)
)
}
refDat <- read.delim(refDat, sep = sep, dec = dec)
} else if (extens == "csv") {
if (is.null(sep)) {
sep <- ";"
warning(
paste(
"sep argument is missing, for a .csv file default field separator is",
deparse(";"),
sep = " "
)
)
}
refDat <- read.csv(refDat, sep = sep, dec = dec)
} else{
stop(
"The extension of refDat is unknown (supported extension: .txt and .csv), \nconsider loading the matrix in R environment and call it within refDat argument"
)
}
} else {
refDat <- refDat
}
# find the position of the particle along its trajectory according to the reference matrix
Res <- unlist(sapply(seq(nrow(df)), function(y) {
if (!is.null(Fun)) {
temp <-
refDat[Fun(df[["y.pos"]][y]), Fun(df[["x.pos"]][y])]
} else{
temp <- refDat[df[["y.pos"]][y], df[["x.pos"]][y]]
}
if (length(temp) == 0) {
temp <- NA
# return a warning message if some values have been not found in refDat
warning(
paste0(
"locaPos returned NA for some values: y.pos = ",
"[", ifelse(!is.null(Fun), Fun(df[["y.pos"]][y]),  df[["y.pos"]][y]),"]",
", x.pos = ",
"[", ifelse(!is.null(Fun), Fun(df[["x.pos"]][y]), df[["x.pos"]][y]), "]",
", these values have been not found in refDat."
)
)
}
return(temp[[1]])
}))
return(Res)
}
## then specify that all values above 254 are considered as the center
refDat[which(refDat > 254)] <- "center"
## rather all values above 0 and below or equal to 254 are considered as within the border
refDat[which(refDat >= 0 & refDat <= 254)] <- "edge"
length(refDat[-which(refDat == "center" | refDat == "edge")])
length(refDat)
refDat[-which(refDat == "center" | refDat == "edge")]
# retrieve the area where the particles
# are located over their whole trajectory using locaPos function
trackDat <- analyseTracklets(trackDat,
customFunc = list(
Position = function(x)
locaPos(
refDat,
x,
Fun = function(y)
ifelse(round(y, digits = 0) == 0,
ceiling(y),
round(y, digits = 0))
)
))
#' @title Perform custom computation over a tracklet list.
#'
#' @description Given a list of data frames containing tracking information for each tracklet and
#' a custom function (or list of functions), this function iterate trough the tracklet lists to perform the specified computation
#' and returns the original list of data frames with the result of the analysis appended.
#'
#' @param trackDat A list of data frame containing tracking information for each tracklet.
#'
#' @param customFunc A function or a list of functions used to perform the computation over all tracklets
#' NB: in case customFunc is a list of unnamed function it will try to retrieve their names by returning the first character string
#' following the function() call as result column name.
#'
#' @param progress A logical value (i.e., TRUE or FALSE) indicating whether a progress bar should be displayed to inform process progression (default = TRUE).
#'
#' @return this function returns the original list of data frames (i.e., tracklet)
#' with the result of the specified computation appended.
#'
#' @author Quentin PETITJEAN
#'
#' @examples
#'
#' set.seed(2023)
#' # generate some dummy tracklets
#' ## start to specify some parameters to generate tracklets
#' TrackN <- 40 # the number of tracklet to simulate
#' TrackL <-
#'   1:1000 # the length of the tracklets or a sequence to randomly sample tracklet length
#' id <- 0
#' TrackList <- stats::setNames(lapply(lapply(seq(TrackN), function(i)
#'   trajr::TrajGenerate(sample(TrackL, 1), random = TRUE, fps = 1)), function(j) {
#'     id <<- id + 1
#'     data.frame(
#'       x.pos = j$x - min(j$x),
#'       y.pos = j$y - min(j$y),
#'       frame = j$time,
#'       identity = paste("Tracklet", id, sep = "_")
#'     )
#'   }), seq(TrackN))
#'
#' # check the tracklets
#' MoveR::drawTracklets(TrackList,
#'                  timeCol = "frame")
#'
#' # Run some computation on the dataset using analyseTracklets
#' TrackList2 <-
#'   MoveR::analyseTracklets(
#'     TrackList,
#'     customFunc = list(
#'       # specify a first function to compute speed over each tracklet (a modulus present within the MoveR package)
#'       speed = function(x)
#'         MoveR::speed(x,
#'                      timeCol = "frame",
#'                      scale = 1),
#'       # compute turning angle in radians over each tracklet (a modulus present within the MoveR package)
#'       TurnAngle = function(x)
#'         MoveR::turnAngle(
#'           x,
#'           timeCol = "frame",
#'           unit = "radians",
#'           scale = 1
#'         ),
#'       # convert the time expressed in frame in second using a conversion factor of 25 frame per second
#'       TimeSec = function(x)
#'         x[["frame"]] / 25,
#'       # or in minutes
#'       TimeMin = function(x)
#'         x[["frame"]] / 25 / 60
#'     )
#'   )
#'
#' # check the result for the first tracklet
#' str(TrackList2[["1"]])
#'
#' # plot the frequency plot of the particles' speed
#' par(mfrow = c(1, 2))
#' hist(MoveR::convert2List(TrackList2)[["speed"]],
#'      main = "Frequency plot of the particles' speed")
#'
#' # plot the frequency plot of the particles' turning angle
#' Ht = circular::circular(
#'   MoveR::convert2List(TrackList2)[["TurnAngle"]],
#'   type = "angle",
#'   units = "radians",
#'   zero = 0
#' )
#' circular::rose.diag(
#'   Ht,
#'   bins = 24,
#'   shrink = 0.89,
#'   xlim = c(-1, 1),
#'   ylim = c(-1, 1),
#'   prop = 2,
#'   col = "gray",
#'   border = "black",
#'   units = 'radians',
#'   ticks = TRUE,
#'   main = "Frequency plot of the particles' turning angle"
#' )
#'
#' @export
analyseTracklets <- function(trackDat,
customFunc,
progress = TRUE) {
if (is.null(customFunc)) {
stop("customFunc argument is missing, a customFunc is needed to compute metric")
}
# if customFunc is a unnamed list of function, retrieve function names
if (is.list(customFunc)) {
if (is.null(names(customFunc))) {
VarName <-
lapply(customFunc, function(x)
strsplit(sub("\\(.*", "", deparse(x)), " ")[[2]])
names(customFunc) <- unlist(VarName)
}
# if customFunc is a function retrieve function names and transformed it to a named list
} else if (is.function(customFunc)) {
VarName <- strsplit(sub("\\(.*", "", deparse(customFunc)), " ")[[2]]
customFunc <- list(customFunc)
names(customFunc) <- VarName
}
# loop trough the tracklet list and append the result to each list by using the name of the custom function
if (isTRUE(progress)) {
total = length(trackDat)
pb <-
progress::progress_bar$new(format = "Processing Tracklets [:bar] :current/:total (:percent)", total = total)
pb$tick(0)
}
# if trackDat is an unnamed list of tracklets use the position of the tracklets in the list as tracklet name
if (is.null(names(trackDat))) {
names(trackDat) <- seq(length(trackDat))
}
for (i in names(trackDat)) {
for (j in names(customFunc)) {
# check whether the customFunc produce an error
e <- simpleError("error")
w <- simpleWarning("warning")
TryFunc <-
tryCatch({
customFunc[[j]](trackDat[[i]])
}, warning = function(w) {
w
}, {
error = function(e)
e
})
if(!inherits(TryFunc, "simpleError") & !inherits(TryFunc, "simpleWarning")) {
trackDat[[i]][[j]] <- TryFunc
} else if (inherits(TryFunc, "simpleError")) {
trackDat[[i]][[j]] <- NA
warning(
"For customFunc ",
"[",j,"]",
" in tracklet ",
"[",i,"]",
", analyseTracklets returned NA, perhaps check customFunc argument:\n",
TryFunc
)
} else if (inherits(TryFunc, "simpleWarning")) {
trackDat[[i]][[j]] <- customFunc[[j]](trackDat[[i]])
#warning(
#  "For customFunc ",
#  "[",j,"]",
#  " in tracklet ",
# "[",i,"]:\n ",
#TryFunc
#)
}
}
if (isTRUE(progress)) {
# progress bar
pb$tick(1)
}
}
return(trackDat)
}
# retrieve the area where the particles
# are located over their whole trajectory using locaPos function
trackDat <- analyseTracklets(trackDat,
customFunc = list(
Position = function(x)
locaPos(
refDat,
x,
Fun = function(y)
ifelse(round(y, digits = 0) == 0,
ceiling(y),
round(y, digits = 0))
)
))
# draw the result, with tracklets part that are on the edge of the arena colored in red
# and those at the center in black
MoveR::drawTracklets(trackDat,
add2It = list(
points(x = arenaEdge[["x.pos"]], y = arenaEdge[["y.pos"]], cex = 0.01),
points(x = arenaCenter[["x.pos"]], y = arenaCenter[["y.pos"]], cex = 0.01)
),
colId = "Position")
# Import the reference dataset (A matrix or dataframe or path to a file (either .txt or .csv) containing a distance matrix to any object or
# the location of one or several areas of interest (here we have created a distance map using ImageJ)
refDat <- read.delim(Path2Data[[2]],
dec = ".")
# Import the reference dataset (A matrix or dataframe or path to a file (either .txt or .csv) containing a distance matrix to any object or
# the location of one or several areas of interest (here we have created a distance map using ImageJ)
refDat <- read.delim(Path2Data[[2]],
dec = ".")
##  transform the refDat as matrix while keeping numeric values
refDat <- matrix(as.numeric(unlist(refDat)), nrow = nrow(refDat))
which(is.numeric(refDat))
is.numeric(refDat)
# Import the reference dataset (A matrix or dataframe or path to a file (either .txt or .csv) containing a distance matrix to any object or
# the location of one or several areas of interest (here we have created a distance map using ImageJ)
refDat <- read.delim(Path2Data[[2]],
dec = ".")
##  transform the refDat as matrix while keeping numeric values
refDat <- matrix(as.numeric(unlist(refDat)), nrow = nrow(refDat))
which(is.numeric(refDat))
is.numeric(refDat)
sapply(refDat, is.numeric())
apply(refDat, 2,is.numeric())
apply(refDat, 2, function(x) is.numeric(x))
test <- apply(refDat, 2, function(x) is.numeric(x))
test <-refDat[apply(refDat, 2, function(x) is.numeric(x))]
test
test <-refDat[!apply(refDat, 2, function(x) is.numeric(x))]
test
apply(refDat, 2, function(x) as.numeric(x))
refDat <- apply(refDat, 2, function(x) as.numeric(x))
# Import the reference dataset (A matrix or dataframe or path to a file (either .txt or .csv) containing a distance matrix to any object or
# the location of one or several areas of interest (here we have created a distance map using ImageJ)
refDat <- read.delim(Path2Data[[2]],
dec = ".")
refDat <- apply(refDat, 2, function(x) as.numeric(x))
##  retrieve the value of the edge limit (1) and of the center limit (254) to plot them
arenaEdge <-
stats::setNames(data.frame(which(refDat == 1, arr.ind = T)),
c("y.pos", "x.pos"))
arenaCenter <-
stats::setNames(data.frame(which(refDat == 254, arr.ind = T)),
c("y.pos", "x.pos"))
## then specify that all values above 254 are considered as the center
refDat[which(refDat > 254)] <- "center"
## rather all values above 0 and below or equal to 254 are considered as within the border
refDat[which(refDat >= 0 & refDat <= 254)] <- "edge"
length(refDat[-which(refDat == "center" | refDat == "edge")])
length(refDat)
# retrieve the area where the particles
# are located over their whole trajectory using locaPos function
trackDat <- analyseTracklets(trackDat,
customFunc = list(
Position = function(x)
locaPos(
refDat,
x,
Fun = function(y)
ifelse(round(y, digits = 0) == 0,
ceiling(y),
round(y, digits = 0))
)
))
# draw the result, with tracklets part that are on the edge of the arena colored in red
# and those at the center in black
MoveR::drawTracklets(trackDat,
add2It = list(
points(x = arenaEdge[["x.pos"]], y = arenaEdge[["y.pos"]], cex = 0.01),
points(x = arenaCenter[["x.pos"]], y = arenaCenter[["y.pos"]], cex = 0.01)
),
colId = "Position")
