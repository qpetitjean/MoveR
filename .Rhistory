# pie chart of behavioral state proportion
act <-
length(which(trackdatL[["actives2"]] == "active")) / length(trackdatL[["actives2"]][-c(which(is.na(trackdatL[["actives2"]])))]) * 100
inact <-
length(which(trackdatL[["actives2"]] == "inactive")) / length(trackdatL[["actives2"]][-c(which(is.na(trackdatL[["actives2"]])))]) * 100
pie(
main = "Proportion of active vs. inactive states",
c(act, inact),
labels = paste(round(
data.frame(active = act,
inactive = inact),
digits = 2
), "%", sep = ""),
col = c("#99CC66", "#993333")
)
legend(
.8,
1.0,
c("active", "inactive"),
cex = 0.8,
fill = c("#99CC66", "#993333")
)
}
Res <- MoveR::convert2frags(trackdatL, by = "trackId")
str(trackdatL)
set.seed(2023)
# generate some dummy tracklets
## start to specify some parameters to generate tracklets
TrackN <- 40 # the number of tracklet to simulate
TrackL <-
1:1000 # the length of the tracklets or a sequence to randomly sample tracklet length
id <- 0
TrackList <- stats::setNames(lapply(lapply(seq(TrackN), function(i)
trajr::TrajGenerate(sample(TrackL, 1), random = TRUE, fps = 1)), function(j) {
id <<- id + 1
data.frame(
x.pos = j$x - min(j$x),
y.pos = j$y - min(j$y),
frame = j$time,
identity = paste("Tracklet", id, sep = "_")
)
}), seq(TrackN))
# check the tracklets
MoveR::drawFrags(TrackList,
timeCol = "frame")
# compute the total surface explored and displays the heatmap for all tracklets
# NB: Plot can be displayed and/or saved using graph and saveGraph arguments
MoveR::exploredArea(TrackList,
binRad = 8,
scale = 1,
timeCol = "frame")
# compute the surface explored for each tracklet and display (but do not save) the heatmap for the 2 first tracklets
# by combining exploredArea and analyseFrags, the surface explored for each tracklet is appended to the data
# of the corresponding tracklets.
ExplorTest <- MoveR::analyseFrags(TrackList[1:2],
customFunc = list(
exploredArea = function(x)
exploredArea(
x,
binRad = 8,
scale = 1,
timeCol = "frame"
)
))
# compute the surface explored for each tracklet and display (but do not save) the heatmap for the 2 first tracklets
# by combining exploredArea and analyseFrags, the surface explored for each tracklet is appended to the data
# of the corresponding tracklets.
ExplorTest <- MoveR::analyseFrags(TrackList[1:2],
customFunc = list(
exploredArea = function(x)
MoveR::exploredArea(
x,
binRad = 8,
scale = 1,
timeCol = "frame"
)
))
str(ExplorTest)
# compute the surface explored for each tracklet and display (but do not save) the heatmap for the 2 first tracklets
# by combining exploredArea and analyseFrags, the surface explored for each tracklet is appended to the data
# of the corresponding tracklets.
ExplorTest <- MoveR::analyseFrags(TrackList[1],
customFunc = list(
exploredArea = function(x)
MoveR::exploredArea(
x,
binRad = 8,
scale = 1,
timeCol = "frame"
)
))
# compute the surface explored for each tracklet and display (but do not save) the heatmap for the 2 first tracklets
# by combining exploredArea and analyseFrags, the surface explored for each tracklet is appended to the data
# of the corresponding tracklets.
ExplorTest <- MoveR::analyseFrags(TrackList[[1]],
customFunc = list(
exploredArea = function(x)
MoveR::exploredArea(
x,
binRad = 8,
scale = 1,
timeCol = "frame"
)
))
# compute the surface explored for each tracklet and display (but do not save) the heatmap for the 2 first tracklets
# by combining exploredArea and analyseFrags, the surface explored for each tracklet is appended to the data
# of the corresponding tracklets.
ExplorTest <- MoveR::analyseFrags(TrackList[1],
customFunc = list(
exploredArea = function(x)
MoveR::exploredArea(
x,
binRad = 8,
scale = 1,
timeCol = "frame"
)
))
# compute the total surface explored and displays the heatmap for all tracklets
# NB: Plot can be displayed and/or saved using graph and saveGraph arguments
MoveR::exploredArea(TrackList,
binRad = 8,
scale = 1,
timeCol = "frame")
# compute the total surface explored and displays the heatmap for all tracklets
# NB: Plot can be displayed and/or saved using graph and saveGraph arguments
MoveR::exploredArea(TrackList,
binRad = 8,
scale = 1,
timeCol = "frame")
# compute the surface explored for each tracklet and display (but do not save) the heatmap for the 2 first tracklets
# by combining exploredArea and analyseFrags, the surface explored for each tracklet is appended to the data
# of the corresponding tracklets.
ExplorTest <- MoveR::analyseFrags(TrackList[1],
customFunc = list(
exploredArea = function(x)
MoveR::exploredArea(
x,
binRad = 8,
scale = 1,
timeCol = "frame"
)
))
binRad = NULL
imgRes = c(NA, NA)
scale = 1
timeCol = "frame"
timeWin = list(c(0, Inf))
graph = TRUE
saveGraph = FALSE
binRad = 8
scale = 1
timeCol = "frame"
trackDat = TrackList[1]
if (is.null(binRad)) {
stop(
"binRad argument is missing, \na numeric value specifying the diameter of the cell a particle can explore is needed to compute the surface explored"
)
}
# if imgRes is unspecified retrieve it approximately using the maximum value in x and y coordinates
if (class(trackDat) == "list" & length(trackDat) >= 1) {
if (TRUE %in% is.na(imgRes)) {
xCoords <- unlist(lapply(trackDat, function(x)
MoveR::listGet(x, "x.pos")))
if (length(which(is.infinite(xCoords)) > 0)) {
xCoords <- xCoords[!is.infinite(xCoords)]
}
width <- round(max(xCoords) + 5 * max(xCoords) / 100, 0)
yCoords <- unlist(lapply(trackDat, function(x)
MoveR::listGet(x, "y.pos")))
if (length(which(is.infinite(yCoords)) > 0)) {
yCoords <- yCoords[!is.infinite(yCoords)]
}
height <- round(max(yCoords) + 5 * max(yCoords) / 100, 0)
imgRes <- c(width, height)
}
}else{
if (TRUE %in% is.na(imgRes)) {
xCoords <- trackDat[["x.pos"]]
if (length(which(is.infinite(xCoords)) > 0)) {
xCoords <- xCoords[!is.infinite(xCoords)]
}
width <- round(max(xCoords) + 5 * max(xCoords) / 100, 0)
yCoords <- trackDat[["y.pos"]]
if (length(which(is.infinite(yCoords)) > 0)) {
yCoords <- yCoords[!is.infinite(yCoords)]
}
height <- round(max(yCoords) + 5 * max(yCoords) / 100, 0)
imgRes <- c(width, height)
}
}
# Select only the part of the tracklets included in the selected time Window
if (!is.list(timeWin)) {
stop(
"timeWin argument should be a list of vector(s) containing starting and ending value of each time window interval"
)
}
if (max(unlist(lapply(timeWin, length))) > 2) {
stop(
"timeWin argument contains a vector of length > 2, \ntimeWin should be a list of vector(s) containing 2 values (start and end of the time window interval)"
)
}
InfLoc <-
length(unlist(lapply(lapply(timeWin, function(x)
which(x == Inf)), function(y)
length(y) > 0)))
if (length(InfLoc) > 0) {
if (class(trackDat) == "list" & length(trackDat) >= 1) {
timeWin[[InfLoc]][which(timeWin[[InfLoc]] == Inf)] <-
max(unlist(lapply(trackDat, function(x)
max(MoveR::listGet(x, timeCol)))))
} else{
# in case the input trackDat contains value for only one tracklet (a dataframe)
timeWin[[InfLoc]][which(timeWin[[InfLoc]] == Inf)] <-
max(MoveR::listGet(trackDat, timeCol), na.rm = T)
}
} else {
timeWin = timeWin
}
# select the part of the tracklets that are included in timeWin
WhoWhen <- lapply(seq(length(timeWin)),
function(p)
MoveR::cutFrags(
trackDat,
customFunc = function(x)
x[[timeCol]] >= timeWin[[p]][[1]] &
x[[timeCol]] <= timeWin[[p]][[2]]
))
WhoWhen <- unlist(WhoWhen, recursive = FALSE)
WhoWhen
str(WhoWhen)
str(MoveR::convert2list(WhoWhen))
# Then, convert the list of tracklet as an unique list (only in case there is several tracklet in trackDat)
trackDatList <- MoveR::convert2list(WhoWhen)
# Compute the surface of a regular hexagon as follow: 3*side*apothem
# where:
# the apothem corresponds to binRad/2
# side corresponds to the length of one side and is computed as follow: apothem * 2 tan(pi/6)
# hence surface is 3 * (binrad/2 * 2 * tan(pi/6)) * binRad/2 which can be simplified
surface <- 1.5 * tan(pi / 6) * binRad ^ 2
## Divide the plane in a hexagonal grid, each cell representing a neighborhood that a particule could 'explore' around its position
## and count the number of unique cells that the particle has entered in at least once using hexagonal heatmaps, as implemented in hexbin package
## compute the number of bins needed given the perception distance of the insect
nbins <- imgRes[1] / binRad
## apply hexbin to count the number of visited cells
nbcells <-
hexbin::hexbin(
trackDatList[["x.pos"]],
trackDatList[["y.pos"]],
xbnds = c(0, imgRes[1]),
ybnds = c(0, imgRes[2]),
xbins = nbins,
shape = 1
)@ncells
### compute the total surface explored, by multiplying the number of visited cells by the surface of one cell and the user-specified scale
Explored <- nbcells * surface * scale
Explored
### plot the result but display it only if graph = T
Exploredplot <- hexbin::hexbinplot(
trackDatList[["y.pos"]] ~
trackDatList[["x.pos"]],
xbins = binRad,
data = trackDatList,
aspect = '1',
main = "Heatmap of the explored areas",
xlab = "Video width (pixels)",
ylab = "Video height (pixels)",
colramp = function(n) {
hexbin::heat.ob(n, beg = 240, end = 1)
},
colorcut = seq(0, 1, length = 10),
cex.labels = 0.9,
xlim = c(0, imgRes[1]),
ylim = c(0, imgRes[2]),
#scales = list(tck=0.25)
scales = list(
y = list(at = pretty(
seq(0, imgRes[2]), n = 6, min.n = 3
)),
x = list(at = pretty(
seq(0, imgRes[1]), n = 6, min.n = 3
)),
tck = 0.25
)
)
if (isTRUE(graph)) {
print(Exploredplot)
}
Exploredplot
print(Exploredplot)
if (isTRUE(graph)) {
print(Exploredplot)
}
if (isTRUE(saveGraph)) {
for (i in seq(1e10)) {
plotname <-
paste(paste("Exploredplot", i, sep = "_"), "tiff", sep = ".")
if (isTRUE(file.exists(paste(getwd(), plotname, sep = "/")))) {
next
} else{
break
}
}
grDevices::tiff(plotname)
print(Exploredplot)
dev.off()
} else if (!isTRUE(saveGraph) & !isFALSE(saveGraph)) {
saveGraph
print(Exploredplot)
dev.off()
}
Explored
### compute the total surface explored, by multiplying the number of visited cells by the surface of one cell and the user-specified scale
Explored <- nbcells * surface * scale
### plot the result but display it only if graph = T
Exploredplot <- hexbin::hexbinplot(
trackDatList[["y.pos"]] ~
trackDatList[["x.pos"]],
xbins = binRad,
data = trackDatList,
aspect = '1',
main = "Heatmap of the explored areas",
xlab = "Video width (pixels)",
ylab = "Video height (pixels)",
colramp = function(n) {
hexbin::heat.ob(n, beg = 240, end = 1)
},
colorcut = seq(0, 1, length = 10),
cex.labels = 0.9,
xlim = c(0, imgRes[1]),
ylim = c(0, imgRes[2]),
#scales = list(tck=0.25)
scales = list(
y = list(at = pretty(
seq(0, imgRes[2]), n = 6, min.n = 3
)),
x = list(at = pretty(
seq(0, imgRes[1]), n = 6, min.n = 3
)),
tck = 0.25
)
)
if (isTRUE(graph)) {
print(Exploredplot)
}
### plot the result but display it only if graph = T
Exploredplot <- hexbin::hexbinplot(
trackDatList[["y.pos"]] ~
trackDatList[["x.pos"]],
xbins = binRad,
data = trackDatList,
aspect = '1',
main = "Heatmap of the explored areas",
xlab = "Video width (pixels)",
ylab = "Video height (pixels)",
colramp = function(n) {
hexbin::heat.ob(n, beg = 240, end = 1)
},
colorcut = seq(0, 1, length = 10),
cex.labels = 0.9,
xlim = c(0, imgRes[1]),
ylim = c(0, imgRes[2]),
#scales = list(tck=0.25)
scales = list(
y = list(at = pretty(
seq(0, imgRes[2]), n = 6, min.n = 3
)),
x = list(at = pretty(
seq(0, imgRes[1]), n = 6, min.n = 3
)),
tck = 0.25
)
)
if (isTRUE(graph)) {
print(Exploredplot)
}
if (isTRUE(saveGraph)) {
for (i in seq(1e10)) {
plotname <-
paste(paste("Exploredplot", i, sep = "_"), "tiff", sep = ".")
if (isTRUE(file.exists(paste(getwd(), plotname, sep = "/")))) {
next
} else{
break
}
}
grDevices::tiff(plotname)
print(Exploredplot)
dev.off()
} else if (!isTRUE(saveGraph) & !isFALSE(saveGraph)) {
saveGraph
print(Exploredplot)
dev.off()
}
customFunc = list(
exploredArea = function(x)
MoveR::exploredArea(
x,
binRad = 8,
scale = 1,
timeCol = "frame"
)
)
if (is.null(customFunc)) {
stop("customFunc argument is missing, a customFunc is needed to compute metric")
}
# if customFunc is a unnamed list of function, retrieve function names
if (is.list(customFunc)) {
if (is.null(names(customFunc))) {
VarName <-
lapply(customFunc, function(x)
strsplit(sub("\\(.*", "", deparse(x)), " ")[[2]])
names(customFunc) <- unlist(VarName)
}
# if customFunc is a function retrieve function names and transformed it to a named list
} else if (is.function(customFunc)) {
VarName <- strsplit(sub("\\(.*", "", deparse(customFunc)), " ")[[2]]
customFunc <- list(customFunc)
names(customFunc) <- VarName
}
# loop trough the tracklet list and append the result to each list by using the name of the custom function
if (isTRUE(progress)) {
total = length(trackDat)
pb <-
progress::progress_bar$new(format = "Processing Tracklets [:bar] :current/:total (:percent)", total = total)
pb$tick(0)
}
# if trackDat is an unnamed list of tracklets use the position of the tracklets in the list as tracklet name
if (is.null(names(trackDat))) {
names(trackDat) <- seq(length(trackDat))
}
names(trackDat)
i="1"
names(customFunc)
j= "exploredArea"
if (!inherits(try(customFunc[[j]](trackDat[[i]]), silent = T)
, "try-error") &
!class(customFunc[[j]](trackDat[[i]])) == "function") {
trackDat[[i]][[j]] <- customFunc[[j]](trackDat[[i]])
} else if (inherits(try(customFunc[[j]](trackDat[[i]]), silent = T)
, "try-error") |
class(customFunc[[j]](trackDat[[i]])) == "function") {
trackDat[[i]][[j]] <- NA
warning(
"For customFunc ",
j ,
" in tracklet ",
i ,
" : \nanalyseFrags returned NA, perhaps check customFunc argument"
)
}
(!inherits(try(customFunc[[j]](trackDat[[i]]), silent = T)
, "try-error") &
!class(customFunc[[j]](trackDat[[i]])) == "function")
customFunc[[j]](trackDat[[i]])
customFunc[[j]]
trackDat[[i]]
customFunc[[j]](trackDat[[i]])
trackDat[[i]][[j]]
trackDat[[i]]
customFunc[[j]](trackDat[[i]])
trackDat[[i]][[j]] <- customFunc[[j]](trackDat[[i]])
for (i in names(trackDat)) {
for (j in names(customFunc)) {
if (!inherits(try(customFunc[[j]](trackDat[[i]]), silent = T)
, "try-error") &
!class(customFunc[[j]](trackDat[[i]])) == "function") {
trackDat[[i]][[j]] <- customFunc[[j]](trackDat[[i]])
} else if (inherits(try(customFunc[[j]](trackDat[[i]]), silent = T)
, "try-error") |
class(customFunc[[j]](trackDat[[i]])) == "function") {
trackDat[[i]][[j]] <- NA
warning(
"For customFunc ",
j ,
" in tracklet ",
i ,
" : \nanalyseFrags returned NA, perhaps check customFunc argument"
)
}
}
if (isTRUE(progress)) {
# progress bar
pb$tick(1)
}
}
for (j in names(customFunc)) {
if (!inherits(try(customFunc[[j]](trackDat[[i]]), silent = T)
, "try-error") &
!class(customFunc[[j]](trackDat[[i]])) == "function") {
trackDat[[i]][[j]] <- customFunc[[j]](trackDat[[i]])
} else if (inherits(try(customFunc[[j]](trackDat[[i]]), silent = T)
, "try-error") |
class(customFunc[[j]](trackDat[[i]])) == "function") {
trackDat[[i]][[j]] <- NA
warning(
"For customFunc ",
j ,
" in tracklet ",
i ,
" : \nanalyseFrags returned NA, perhaps check customFunc argument"
)
}
}
(inherits(try(customFunc[[j]](trackDat[[i]]), silent = T)
, "try-error") |
class(customFunc[[j]](trackDat[[i]])) == "function")
?try
tryCatch(customFunc[[j]](trackDat[[i]]), error = function(e) e)
tryCatch(customFunc[[j]](trackDat[[i]]))
tryCatch(customFunc[[j]](trackDat[[i]]), silent = T)
tryCatch(customFunc[[j]](trackDat[[i]]), error = function(e) "")
tryCatch(customFunc[[j]](trackDat[[i]]), error = function(e) "")
